// This file was generated by IndexBuffers Compiler 0.4-beta.
// https://github.com/yurablok/IndexBuffers
// Do not modify.
#ifndef ADDRESSBOOK_GENERATED_HPP
#define ADDRESSBOOK_GENERATED_HPP

#include <cstdint>
#include <memory>
#include <vector>
#include <string>
#include <unordered_map>

namespace ibs {

struct PhoneNumberType { // enum PhoneNumberType
enum _ : uint16_t {
    mobile = 0,
    home = 1,
    work = 2,
    _SPECIAL_ = 3
};
static const char* to_string(const _ __value__) {
    switch(__value__) {
    case mobile: return "mobile";
    case home: return "home";
    case work: return "work";
    default: break;
    }
    return nullptr;
}
template <typename string_t>
static _ from_string(const string_t& __value__) {
    static const std::unordered_map<string_t, _> map = {
        { "mobile", mobile },
        { "home", home },
        { "work", work }
    };
    const auto it = map.find(__value__);
    if (it == map.end()) {
        return _SPECIAL_;
    }
    return it->second;
}
static _ from_string(const char* __value__) {
    return from_string(std::string(__value__));
}
static constexpr _ min() {
    return mobile;
}
static constexpr _ max() {
    return work;
}
static constexpr uint16_t count() {
    return 3;
}
static _ at(const uint16_t __value__) {
    switch (__value__) {
    case 0: return mobile;
    case 1: return home;
    case 2: return work;
    default: break;
    }
    return _SPECIAL_;
}
}; // enum PhoneNumberType

class PhoneNumber { // struct PhoneNumber
public:
    PhoneNumber() {}
    PhoneNumber(void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    PhoneNumber(const void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = sizeof(header);
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(header) + sizeof(table));
            m_table_offset = sizeof(header);
            new(base_ptr()) header();
        }
        new(get_table()) table();
    }
    bool from(void* from_ptr, const uint16_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = sizeof(header);
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        auto h = reinterpret_cast<const header*>(base_ptr());
        if (h->___i != 'i' || h->___b != 'b' || h->___s != 's') {
            return false;
        }
        if (h->___sh != 1240880896) {
            return false;
        }
        return true;
    }
    bool from(const void* from_ptr, const uint16_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint16_t table_offset, const void* from_ptr,
            const uint16_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<PhoneNumber*>(this)->to();
    }
    uint16_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (calculate > 2) {
                    m_from_size += sizeof(header);
                }
                m_from_size += size_number() + sizeof(uint16_t);
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint16_t>(m_buffer->size());
        }
        return 0;
    }
    static uint16_t size_min() {
        return 12;
    }
    static uint16_t size_max() {
        return 65535;
    }
    
    struct fields { // enum fields
    enum _ : uint16_t {
        number = 0,
        type = 1,
        _SPECIAL_ = 2
    };
    static const char* to_string(const _ __value__) {
        switch(__value__) {
        case number: return "number";
        case type: return "type";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& __value__) {
        static const std::unordered_map<string_t, _> map = {
            { "number", number },
            { "type", type }
        };
        const auto it = map.find(__value__);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* __value__) {
        return from_string(std::string(__value__));
    }
    static constexpr _ min() {
        return number;
    }
    static constexpr _ max() {
        return type;
    }
    static constexpr uint16_t count() {
        return 2;
    }
    static _ at(const uint16_t __value__) {
        switch (__value__) {
        case 0: return number;
        case 1: return type;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint16_t offset(const fields::_ field) const {
        static const table o{};
        const table* t = get_table();
        switch (field) {
        case fields::number: return t->__number;
        case fields::type: return m_table_offset + static_cast<uint16_t>(
            reinterpret_cast<uintptr_t>(&o.type) - reinterpret_cast<uintptr_t>(&o));
        }
        return 0;
    }
    bool has(const fields::_ field) const {
        switch (field) {
        case fields::number: return offset(field) > 0;
        case fields::type: return true;
        }
        return false;
    }
    void* get(const fields::_ field) {
        switch (field) {
        case fields::number: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field) + sizeof(uint16_t);
        case fields::type: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<PhoneNumber*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint16_t size) {
        if (!has(field)) {
            if (m_from_ptr) {
                return;
            }
            switch (field) {
            case fields::number:
                get_table()->__number = static_cast<uint16_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(uint8_t) * size + sizeof(uint16_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->__number)) = size;
                break;
            default: return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint16_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::number:
            return *(reinterpret_cast<const uint16_t*>(get(field)) - 1);
        case fields::type:
            return sizeof(ibs::PhoneNumberType::_);
        default:
            return 0;
        }
        return 0;
    }

    bool has_number() const {
        return has(fields::number);
    }
    uint8_t& get_number(const uint16_t index) {
        return reinterpret_cast<uint8_t*>(get(fields::number))[index];
    }
    const uint8_t& get_number(const uint16_t index) const {
        return const_cast<PhoneNumber*>(this)->get_number(index);
    }
    template <typename bytes_t>
    bytes_t get_number() const {
        bytes_t bytes;
        bytes.resize(size_number());
        std::copy(reinterpret_cast<const uint8_t*>(get(fields::number)),
            reinterpret_cast<const uint8_t*>(get(fields::number)) + size_number(),
            reinterpret_cast<uint8_t*>(&bytes[0]));
        return bytes;
    }
    template <typename bytes_t>
    void set_number(const bytes_t& bytes) {
        set(fields::number, bytes.data(), static_cast<uint16_t>(bytes.size()));
    }
    void set_number(const uint16_t size) {
        set(fields::number, nullptr, size);
    }
    uint16_t size_number() const {
        return size(fields::number);
    }
    bool has_type() const {
        return has(fields::type);
    }
    ibs::PhoneNumberType::_ get_type() {
        return *reinterpret_cast<ibs::PhoneNumberType::_*>(get(fields::type));
    }
    const ibs::PhoneNumberType::_& get_type() const {
        return const_cast<PhoneNumber*>(this)->get_type();
    }
    void set_type(const ibs::PhoneNumberType::_ value) {
        set(fields::type, &value, sizeof(ibs::PhoneNumberType::_));
    }

    #pragma pack(1)
    struct header {
        int8_t ___i = 'i';
        int8_t ___b = 'b';
        int8_t ___s = 's';
        uint8_t ___v = (3 << 4) | 0;
        uint32_t ___sh = 1240880896;
    };
    struct table {
        uint16_t __number = 0;
        ibs::PhoneNumberType::_ type;
    };
    #pragma pack()
private:
    table* get_table() {
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<PhoneNumber*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<PhoneNumber*>(this)->base_ptr();
    }
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint16_t m_from_size = 0;
    uint16_t m_table_offset = 0;
}; // struct PhoneNumber

class Employment { // union Employment
public:
    Employment() {}
    Employment(void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    Employment(const void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = sizeof(header);
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(header) + sizeof(table));
            m_table_offset = sizeof(header);
            new(base_ptr()) header();
        }
        new(get_table()) table();
    }
    bool from(void* from_ptr, const uint16_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = sizeof(header);
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        auto h = reinterpret_cast<const header*>(base_ptr());
        if (h->___i != 'i' || h->___b != 'b' || h->___s != 's') {
            return false;
        }
        if (h->___sh != 413630765) {
            return false;
        }
        return true;
    }
    bool from(const void* from_ptr, const uint16_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint16_t table_offset, const void* from_ptr,
            const uint16_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<Employment*>(this)->to();
    }
    uint16_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (calculate > 2) {
                    m_from_size += sizeof(header);
                }
                switch (get_table()->variant) {
                case fields::unemployed:
                    m_from_size += size(fields::unemployed);
                    break;
                case fields::employer:
                    m_from_size += size_employer() + sizeof(uint16_t);
                    break;
                case fields::school:
                    m_from_size += size_school() + sizeof(uint16_t);
                    break;
                case fields::selfEmployed:
                    m_from_size += size(fields::selfEmployed);
                    break;
                default: break;
                }
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint16_t>(m_buffer->size());
        }
        return 0;
    }
    static uint16_t size_min() {
        return 12;
    }
    static uint16_t size_max() {
        return 65535;
    }
    
    struct fields { // enum fields
    enum _ : uint16_t {
        unemployed = 0,
        employer = 1,
        school = 2,
        selfEmployed = 3,
        _SPECIAL_ = 4
    };
    static const char* to_string(const _ __value__) {
        switch(__value__) {
        case unemployed: return "unemployed";
        case employer: return "employer";
        case school: return "school";
        case selfEmployed: return "selfEmployed";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& __value__) {
        static const std::unordered_map<string_t, _> map = {
            { "unemployed", unemployed },
            { "employer", employer },
            { "school", school },
            { "selfEmployed", selfEmployed }
        };
        const auto it = map.find(__value__);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* __value__) {
        return from_string(std::string(__value__));
    }
    static constexpr _ min() {
        return unemployed;
    }
    static constexpr _ max() {
        return selfEmployed;
    }
    static constexpr uint16_t count() {
        return 4;
    }
    static _ at(const uint16_t __value__) {
        switch (__value__) {
        case 0: return unemployed;
        case 1: return employer;
        case 2: return school;
        case 3: return selfEmployed;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint16_t offset() const {
        return get_table()->offset;
    }
    fields::_ variant() const {
        return get_table()->variant;
    }
    bool has(const fields::_ field) const {
        return get_table()->variant == field;
    }
    void* get(const fields::_ field) {
        switch (get_table()->variant) {
        case fields::unemployed: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset();
        case fields::employer: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset() + sizeof(uint16_t);
        case fields::school: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset() + sizeof(uint16_t);
        case fields::selfEmployed: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset();
        default: break;
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<Employment*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint16_t size) {
        if (get_table()->variant == fields::_SPECIAL_) {
            if (m_from_ptr) {
                return;
            }
            get_table()->variant = field;
            get_table()->offset = static_cast<uint16_t>(m_buffer->size());
            switch (field) {
            case fields::unemployed:
                m_buffer->resize(m_buffer->size() + sizeof(uint8_t));
                break;
            case fields::employer:
                m_buffer->resize(m_buffer->size() + sizeof(uint16_t)
                    + size * sizeof(uint8_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->offset)) = size;
                break;
            case fields::school:
                m_buffer->resize(m_buffer->size() + sizeof(uint16_t)
                    + size * sizeof(uint8_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->offset)) = size;
                break;
            case fields::selfEmployed:
                m_buffer->resize(m_buffer->size() + sizeof(uint8_t));
                break;
            default: return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint16_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::unemployed:
            return sizeof(uint8_t);
        case fields::employer:
            return *(reinterpret_cast<const uint16_t*>(get(field)) - 1);
        case fields::school:
            return *(reinterpret_cast<const uint16_t*>(get(field)) - 1);
        case fields::selfEmployed:
            return sizeof(uint8_t);
        default:
            return 0;
        }
        return 0;
    }

    bool has_unemployed() const {
        return has(fields::unemployed);
    }
    uint8_t get_unemployed() {
        return *reinterpret_cast<uint8_t*>(get(fields::unemployed));
    }
    const uint8_t& get_unemployed() const {
        return const_cast<Employment*>(this)->get_unemployed();
    }
    void set_unemployed(const uint8_t value) {
        set(fields::unemployed, &value, sizeof(uint8_t));
    }
    bool has_employer() const {
        return has(fields::employer);
    }
    uint8_t& get_employer(const uint16_t index) {
        return reinterpret_cast<uint8_t*>(get(fields::employer))[index];
    }
    const uint8_t& get_employer(const uint16_t index) const {
        return const_cast<Employment*>(this)->get_employer(index);
    }
    template <typename bytes_t>
    bytes_t get_employer() const {
        bytes_t bytes;
        bytes.resize(size_employer());
        std::copy(reinterpret_cast<const uint8_t*>(get(fields::employer)),
            reinterpret_cast<const uint8_t*>(get(fields::employer)) + size_employer(),
            reinterpret_cast<uint8_t*>(&bytes[0]));
        return bytes;
    }
    template <typename bytes_t>
    void set_employer(const bytes_t& bytes) {
        set(fields::employer, bytes.data(), bytes.size());
    }
    void set_employer(const uint16_t size) {
        set(fields::employer, nullptr, size);
    }
    uint16_t size_employer() const {
        return size(fields::employer);
    }
    bool has_school() const {
        return has(fields::school);
    }
    uint8_t& get_school(const uint16_t index) {
        return reinterpret_cast<uint8_t*>(get(fields::school))[index];
    }
    const uint8_t& get_school(const uint16_t index) const {
        return const_cast<Employment*>(this)->get_school(index);
    }
    template <typename bytes_t>
    bytes_t get_school() const {
        bytes_t bytes;
        bytes.resize(size_school());
        std::copy(reinterpret_cast<const uint8_t*>(get(fields::school)),
            reinterpret_cast<const uint8_t*>(get(fields::school)) + size_school(),
            reinterpret_cast<uint8_t*>(&bytes[0]));
        return bytes;
    }
    template <typename bytes_t>
    void set_school(const bytes_t& bytes) {
        set(fields::school, bytes.data(), bytes.size());
    }
    void set_school(const uint16_t size) {
        set(fields::school, nullptr, size);
    }
    uint16_t size_school() const {
        return size(fields::school);
    }
    bool has_selfEmployed() const {
        return has(fields::selfEmployed);
    }
    uint8_t get_selfEmployed() {
        return *reinterpret_cast<uint8_t*>(get(fields::selfEmployed));
    }
    const uint8_t& get_selfEmployed() const {
        return const_cast<Employment*>(this)->get_selfEmployed();
    }
    void set_selfEmployed(const uint8_t value) {
        set(fields::selfEmployed, &value, sizeof(uint8_t));
    }

    #pragma pack(1)
    struct header {
        int8_t ___i = 'i';
        int8_t ___b = 'b';
        int8_t ___s = 's';
        uint8_t ___v = (3 << 4) | 0;
        uint32_t ___sh = 413630765;
    };
    struct table {
        fields::_ variant = fields::_SPECIAL_;
        uint16_t offset = 0;
    };
    #pragma pack()
private:
    table* get_table() {
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<Employment*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<Employment*>(this)->base_ptr();
    }
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint16_t m_from_size = 0;
    uint16_t m_table_offset = 0;
}; // union Employment

class Person { // struct Person
public:
    Person() {}
    Person(void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    Person(const void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = sizeof(header);
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(header) + sizeof(table));
            m_table_offset = sizeof(header);
            new(base_ptr()) header();
        }
        new(get_table()) table();
        get_employment().create(UINT32_MAX);
    }
    bool from(void* from_ptr, const uint16_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = sizeof(header);
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        auto h = reinterpret_cast<const header*>(base_ptr());
        if (h->___i != 'i' || h->___b != 'b' || h->___s != 's') {
            return false;
        }
        if (h->___sh != 814211368) {
            return false;
        }
        return true;
    }
    bool from(const void* from_ptr, const uint16_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint16_t table_offset, const void* from_ptr,
            const uint16_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<Person*>(this)->to();
    }
    uint16_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (calculate > 2) {
                    m_from_size += sizeof(header);
                }
                m_from_size += size_name() + sizeof(uint16_t);
                m_from_size += size_email() + sizeof(uint16_t);
                if (has_phones()) {
                    for (uint16_t i = 0, s = size_phones(); i < s; ++i) {
                        m_from_size += get_phones(i).size(2);
                    } m_from_size += sizeof(uint16_t);
                }
                m_from_size += get_employment().size(1);
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint16_t>(m_buffer->size());
        }
        return 0;
    }
    static uint16_t size_min() {
        return 22;
    }
    static uint16_t size_max() {
        return 65535;
    }
    
    struct fields { // enum fields
    enum _ : uint16_t {
        id = 0,
        name = 1,
        email = 2,
        phones = 3,
        employment = 4,
        _SPECIAL_ = 5
    };
    static const char* to_string(const _ __value__) {
        switch(__value__) {
        case id: return "id";
        case name: return "name";
        case email: return "email";
        case phones: return "phones";
        case employment: return "employment";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& __value__) {
        static const std::unordered_map<string_t, _> map = {
            { "id", id },
            { "name", name },
            { "email", email },
            { "phones", phones },
            { "employment", employment }
        };
        const auto it = map.find(__value__);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* __value__) {
        return from_string(std::string(__value__));
    }
    static constexpr _ min() {
        return id;
    }
    static constexpr _ max() {
        return employment;
    }
    static constexpr uint16_t count() {
        return 5;
    }
    static _ at(const uint16_t __value__) {
        switch (__value__) {
        case 0: return id;
        case 1: return name;
        case 2: return email;
        case 3: return phones;
        case 4: return employment;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint16_t offset(const fields::_ field) const {
        static const table o{};
        const table* t = get_table();
        switch (field) {
        case fields::id: return m_table_offset + static_cast<uint16_t>(
            reinterpret_cast<uintptr_t>(&o.id) - reinterpret_cast<uintptr_t>(&o));
        case fields::name: return t->__name;
        case fields::email: return t->__email;
        case fields::phones: return t->__phones;
        case fields::employment: return m_table_offset + static_cast<uint16_t>(
            reinterpret_cast<uintptr_t>(&o.employment) - reinterpret_cast<uintptr_t>(&o));
        }
        return 0;
    }
    bool has(const fields::_ field) const {
        switch (field) {
        case fields::id: return true;
        case fields::name: return offset(field) > 0;
        case fields::email: return offset(field) > 0;
        case fields::phones: return offset(field) > 0;
        case fields::employment: return true;
        }
        return false;
    }
    void* get(const fields::_ field) {
        switch (field) {
        case fields::id: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::name: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field) + sizeof(uint16_t);
        case fields::email: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field) + sizeof(uint16_t);
        case fields::phones: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field) + sizeof(uint16_t);
        case fields::employment: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<Person*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint16_t size) {
        if (!has(field)) {
            if (m_from_ptr) {
                return;
            }
            switch (field) {
            case fields::name:
                get_table()->__name = static_cast<uint16_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(uint8_t) * size + sizeof(uint16_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->__name)) = size;
                break;
            case fields::email:
                get_table()->__email = static_cast<uint16_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(uint8_t) * size + sizeof(uint16_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->__email)) = size;
                break;
            case fields::phones:
                get_table()->__phones = static_cast<uint16_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(ibs::PhoneNumber::table) * size + sizeof(uint16_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->__phones)) = size;
                for (uint16_t i = 0; i < size; ++i) {
                    get_phones(i).create(UINT32_MAX);
                }
                break;
            default: return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint16_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::id:
            return sizeof(uint32_t);
        case fields::name:
            return *(reinterpret_cast<const uint16_t*>(get(field)) - 1);
        case fields::email:
            return *(reinterpret_cast<const uint16_t*>(get(field)) - 1);
        case fields::phones:
            return *(reinterpret_cast<const uint16_t*>(get(field)) - 1);
        case fields::employment:
            return sizeof(ibs::Employment::table);
        default:
            return 0;
        }
        return 0;
    }

    bool has_id() const {
        return has(fields::id);
    }
    uint32_t get_id() {
        return *reinterpret_cast<uint32_t*>(get(fields::id));
    }
    const uint32_t& get_id() const {
        return const_cast<Person*>(this)->get_id();
    }
    void set_id(const uint32_t value) {
        set(fields::id, &value, sizeof(uint32_t));
    }
    bool has_name() const {
        return has(fields::name);
    }
    uint8_t& get_name(const uint16_t index) {
        return reinterpret_cast<uint8_t*>(get(fields::name))[index];
    }
    const uint8_t& get_name(const uint16_t index) const {
        return const_cast<Person*>(this)->get_name(index);
    }
    template <typename bytes_t>
    bytes_t get_name() const {
        bytes_t bytes;
        bytes.resize(size_name());
        std::copy(reinterpret_cast<const uint8_t*>(get(fields::name)),
            reinterpret_cast<const uint8_t*>(get(fields::name)) + size_name(),
            reinterpret_cast<uint8_t*>(&bytes[0]));
        return bytes;
    }
    template <typename bytes_t>
    void set_name(const bytes_t& bytes) {
        set(fields::name, bytes.data(), static_cast<uint16_t>(bytes.size()));
    }
    void set_name(const uint16_t size) {
        set(fields::name, nullptr, size);
    }
    uint16_t size_name() const {
        return size(fields::name);
    }
    bool has_email() const {
        return has(fields::email);
    }
    uint8_t& get_email(const uint16_t index) {
        return reinterpret_cast<uint8_t*>(get(fields::email))[index];
    }
    const uint8_t& get_email(const uint16_t index) const {
        return const_cast<Person*>(this)->get_email(index);
    }
    template <typename bytes_t>
    bytes_t get_email() const {
        bytes_t bytes;
        bytes.resize(size_email());
        std::copy(reinterpret_cast<const uint8_t*>(get(fields::email)),
            reinterpret_cast<const uint8_t*>(get(fields::email)) + size_email(),
            reinterpret_cast<uint8_t*>(&bytes[0]));
        return bytes;
    }
    template <typename bytes_t>
    void set_email(const bytes_t& bytes) {
        set(fields::email, bytes.data(), static_cast<uint16_t>(bytes.size()));
    }
    void set_email(const uint16_t size) {
        set(fields::email, nullptr, size);
    }
    uint16_t size_email() const {
        return size(fields::email);
    }
    bool has_phones() const {
        return has(fields::phones);
    }
    ibs::PhoneNumber& get_phones(const uint16_t index) {
        static thread_local ibs::PhoneNumber phones;
        const auto phones_t = &reinterpret_cast<ibs::PhoneNumber::table*>(get(fields::phones))[index];
        const uint16_t table_offset = static_cast<uint16_t>(
            reinterpret_cast<const uint8_t*>(phones_t)
            - reinterpret_cast<const uint8_t*>(base_ptr()));
        phones.from(table_offset, m_from_ptr, 0, m_buffer);
        return phones;
    }
    const ibs::PhoneNumber& get_phones(const uint16_t index) const {
        return const_cast<Person*>(this)->get_phones(index);
    }
    void set_phones(const uint16_t size) {
        set(fields::phones, nullptr, size);
    }
    uint16_t size_phones() const {
        return size(fields::phones);
    }
    bool has_employment() const {
        return has(fields::employment);
    }
    ibs::Employment& get_employment() {
        static thread_local ibs::Employment employment;
        const auto employment_t = reinterpret_cast<ibs::Employment::table*>(get(fields::employment));
        const uint16_t table_offset = static_cast<uint16_t>(
            reinterpret_cast<const uint8_t*>(employment_t)
            - reinterpret_cast<const uint8_t*>(base_ptr()));
        employment.from(table_offset, m_from_ptr, 0, m_buffer);
        return employment;
    }
    const ibs::Employment& get_employment() const {
        return const_cast<Person*>(this)->get_employment();
    }
    void set_employment() {
        set(fields::employment, nullptr, sizeof(ibs::Employment::table));
    }

    #pragma pack(1)
    struct header {
        int8_t ___i = 'i';
        int8_t ___b = 'b';
        int8_t ___s = 's';
        uint8_t ___v = (3 << 4) | 0;
        uint32_t ___sh = 814211368;
    };
    struct table {
        uint32_t id;
        uint16_t __name = 0;
        uint16_t __email = 0;
        uint16_t __phones = 0;
        ibs::Employment::table employment;
    };
    #pragma pack()
private:
    table* get_table() {
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<Person*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<Person*>(this)->base_ptr();
    }
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint16_t m_from_size = 0;
    uint16_t m_table_offset = 0;
}; // struct Person

class AddressBook { // struct AddressBook
public:
    AddressBook() {}
    AddressBook(void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    AddressBook(const void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = 0;
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(table));
            m_table_offset = 0;
        }
        new(get_table()) table();
    }
    bool from(void* from_ptr, const uint16_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = 0;
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        return true;
    }
    bool from(const void* from_ptr, const uint16_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint16_t table_offset, const void* from_ptr,
            const uint16_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<AddressBook*>(this)->to();
    }
    uint16_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (has_people()) {
                    for (uint16_t i = 0, s = size_people(); i < s; ++i) {
                        m_from_size += get_people(i).size(2);
                    } m_from_size += sizeof(uint16_t);
                }
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint16_t>(m_buffer->size());
        }
        return 0;
    }
    static uint16_t size_min() {
        return 2;
    }
    static uint16_t size_max() {
        return 65535;
    }
    
    struct fields { // enum fields
    enum _ : uint16_t {
        people = 0,
        _SPECIAL_ = 1
    };
    static const char* to_string(const _ __value__) {
        switch(__value__) {
        case people: return "people";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& __value__) {
        static const std::unordered_map<string_t, _> map = {
            { "people", people }
        };
        const auto it = map.find(__value__);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* __value__) {
        return from_string(std::string(__value__));
    }
    static constexpr _ min() {
        return people;
    }
    static constexpr _ max() {
        return people;
    }
    static constexpr uint16_t count() {
        return 1;
    }
    static _ at(const uint16_t __value__) {
        switch (__value__) {
        case 0: return people;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint16_t offset(const fields::_ field) const {
        static const table o{};
        const table* t = get_table();
        switch (field) {
        case fields::people: return t->__people;
        }
        return 0;
    }
    bool has(const fields::_ field) const {
        switch (field) {
        case fields::people: return offset(field) > 0;
        }
        return false;
    }
    void* get(const fields::_ field) {
        switch (field) {
        case fields::people: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field) + sizeof(uint16_t);
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<AddressBook*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint16_t size) {
        if (!has(field)) {
            if (m_from_ptr) {
                return;
            }
            switch (field) {
            case fields::people:
                get_table()->__people = static_cast<uint16_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(ibs::Person::table) * size + sizeof(uint16_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->__people)) = size;
                for (uint16_t i = 0; i < size; ++i) {
                    get_people(i).create(UINT32_MAX);
                }
                break;
            default: return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint16_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::people:
            return *(reinterpret_cast<const uint16_t*>(get(field)) - 1);
        default:
            return 0;
        }
        return 0;
    }

    bool has_people() const {
        return has(fields::people);
    }
    ibs::Person& get_people(const uint16_t index) {
        static thread_local ibs::Person people;
        const auto people_t = &reinterpret_cast<ibs::Person::table*>(get(fields::people))[index];
        const uint16_t table_offset = static_cast<uint16_t>(
            reinterpret_cast<const uint8_t*>(people_t)
            - reinterpret_cast<const uint8_t*>(base_ptr()));
        people.from(table_offset, m_from_ptr, 0, m_buffer);
        return people;
    }
    const ibs::Person& get_people(const uint16_t index) const {
        return const_cast<AddressBook*>(this)->get_people(index);
    }
    void set_people(const uint16_t size) {
        set(fields::people, nullptr, size);
    }
    uint16_t size_people() const {
        return size(fields::people);
    }

    #pragma pack(1)
    struct table {
        uint16_t __people = 0;
    };
    #pragma pack()
private:
    table* get_table() {
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<AddressBook*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<AddressBook*>(this)->base_ptr();
    }
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint16_t m_from_size = 0;
    uint16_t m_table_offset = 0;
}; // struct AddressBook

} // ibs

#endif // ADDRESSBOOK_GENERATED_HPP
