// This file was generated by IndexBuffers Compiler 0.4-beta.
// https://github.com/yurablok/IndexBuffers
// Do not modify.
#ifndef SCHEMA_GENERATED_HPP
#define SCHEMA_GENERATED_HPP

#include <cstdint>
#include <memory>
#include <vector>
#include <string>
#include <unordered_map>
#include "additional_generated.hpp"

namespace ExtNS {
namespace IntNS {

struct Color { // enum Color
enum _ : uint8_t {
    RED = 0,
    GREEN = 3,
    BLUE = 4,
    _SPECIAL_ = 5
};
static const char* to_string(const _ enum_value) {
    switch(enum_value) {
    case RED: return "RED";
    case GREEN: return "GREEN";
    case BLUE: return "BLUE";
    default: break;
    }
    return nullptr;
}
template <typename string_t>
static _ from_string(const string_t& string_value) {
    static const std::unordered_map<string_t, _> map = {
        { "RED", RED },
        { "GREEN", GREEN },
        { "BLUE", BLUE }
    };
    const auto it = map.find(string_value);
    if (it == map.end()) {
        return _SPECIAL_;
    }
    return it->second;
}
static _ from_string(const char* string_value) {
    return from_string(std::string(string_value));
}
static constexpr _ min() {
    return RED;
}
static constexpr _ max() {
    return BLUE;
}
static constexpr uint8_t count() {
    return 3;
}
static _ at(const uint8_t index) {
    switch (index) {
    case 0: return RED;
    case 1: return GREEN;
    case 2: return BLUE;
    default: break;
    }
    return _SPECIAL_;
}
}; // enum Color

class ScalarTypes { // struct ScalarTypes
public:
    ScalarTypes() {}
    ScalarTypes(void* from_ptr, const uint8_t from_size = 0) {
        from(from_ptr, from_size);
    }
    ScalarTypes(const void* from_ptr, const uint8_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = sizeof(header);
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(header) + sizeof(table));
            m_table_offset = sizeof(header);
            new(base_ptr()) header();
        }
        new(get_table()) table();
    }
    bool from(void* from_ptr, const uint8_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = sizeof(header);
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        auto h = reinterpret_cast<const header*>(base_ptr());
        if (h->___i != 'i' || h->___b != 'b' || h->___s != 's') {
            return false;
        }
        if (h->___sh != 3124513763) {
            return false;
        }
        return true;
    }
    bool from(const void* from_ptr, const uint8_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint8_t table_offset, const void* from_ptr,
            const uint8_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<ScalarTypes*>(this)->to();
    }
    uint8_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (calculate > 2) {
                    m_from_size += sizeof(header);
                }
                if (has_c()) {
                    m_from_size += size(fields::c);
                }
                if (has_d()) {
                    m_from_size += size(fields::d);
                }
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint8_t>(m_buffer->size());
        }
        return 0;
    }
    static uint8_t size_min() {
        return 25;
    }
    static uint8_t size_max() {
        return 37;
    }
    
    struct fields { // enum fields
    enum _ : uint8_t {
        a = 0,
        b = 1,
        c = 2,
        d = 3,
        e = 4,
        f = 5,
        _SPECIAL_ = 6
    };
    static const char* to_string(const _ enum_value) {
        switch(enum_value) {
        case a: return "a";
        case b: return "b";
        case c: return "c";
        case d: return "d";
        case e: return "e";
        case f: return "f";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& string_value) {
        static const std::unordered_map<string_t, _> map = {
            { "a", a },
            { "b", b },
            { "c", c },
            { "d", d },
            { "e", e },
            { "f", f }
        };
        const auto it = map.find(string_value);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* string_value) {
        return from_string(std::string(string_value));
    }
    static constexpr _ min() {
        return a;
    }
    static constexpr _ max() {
        return f;
    }
    static constexpr uint8_t count() {
        return 6;
    }
    static _ at(const uint8_t index) {
        switch (index) {
        case 0: return a;
        case 1: return b;
        case 2: return c;
        case 3: return d;
        case 4: return e;
        case 5: return f;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint8_t offset(const fields::_ field) const {
        static const table o{};
        const table* t = get_table();
        switch (field) {
        case fields::a: return m_table_offset + static_cast<uint8_t>(
            reinterpret_cast<uintptr_t>(&o.a) - reinterpret_cast<uintptr_t>(&o));
        case fields::b: return m_table_offset + static_cast<uint8_t>(
            reinterpret_cast<uintptr_t>(&o.b) - reinterpret_cast<uintptr_t>(&o));
        case fields::c: return t->__c;
        case fields::d: return t->__d;
        case fields::e: return m_table_offset + static_cast<uint8_t>(
            reinterpret_cast<uintptr_t>(&o.e) - reinterpret_cast<uintptr_t>(&o));
        case fields::f: return m_table_offset + static_cast<uint8_t>(
            reinterpret_cast<uintptr_t>(&o.f) - reinterpret_cast<uintptr_t>(&o));
        }
        return 0;
    }
    bool has(const fields::_ field) const {
        switch (field) {
        case fields::a: return true;
        case fields::b: return true;
        case fields::c: return offset(field) > 0;
        case fields::d: return offset(field) > 0;
        case fields::e: return true;
        case fields::f: return true;
        }
        return false;
    }
    void* get(const fields::_ field) {
        switch (field) {
        case fields::a: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::b: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::c: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::d: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::e: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::f: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<ScalarTypes*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint8_t size) {
        if (!has(field)) {
            if (m_from_ptr) {
                return;
            }
            switch (field) {
            case fields::c:
                get_table()->__c = static_cast<uint8_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(int32_t));
                break;
            case fields::d:
                get_table()->__d = static_cast<uint8_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(uint64_t));
                break;
            default: return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint8_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::a:
            return sizeof(int8_t);
        case fields::b:
            return sizeof(uint16_t);
        case fields::c:
            return sizeof(int32_t);
        case fields::d:
            return sizeof(uint64_t);
        case fields::e:
            return sizeof(float);
        case fields::f:
            return sizeof(double);
        default:
            return 0;
        }
        return 0;
    }

    bool has_a() const {
        return has(fields::a);
    }
    int8_t get_a() {
        return *reinterpret_cast<int8_t*>(get(fields::a));
    }
    const int8_t& get_a() const {
        return const_cast<ScalarTypes*>(this)->get_a();
    }
    void set_a(const int8_t value) {
        set(fields::a, &value, sizeof(int8_t));
    }
    bool has_b() const {
        return has(fields::b);
    }
    uint16_t get_b() {
        return *reinterpret_cast<uint16_t*>(get(fields::b));
    }
    const uint16_t& get_b() const {
        return const_cast<ScalarTypes*>(this)->get_b();
    }
    void set_b(const uint16_t value) {
        set(fields::b, &value, sizeof(uint16_t));
    }
    bool has_c() const {
        return has(fields::c);
    }
    int32_t get_c() {
        return *reinterpret_cast<int32_t*>(get(fields::c));
    }
    const int32_t& get_c() const {
        return const_cast<ScalarTypes*>(this)->get_c();
    }
    void set_c(const int32_t value) {
        set(fields::c, &value, sizeof(int32_t));
    }
    bool has_d() const {
        return has(fields::d);
    }
    uint64_t get_d() {
        return *reinterpret_cast<uint64_t*>(get(fields::d));
    }
    const uint64_t& get_d() const {
        return const_cast<ScalarTypes*>(this)->get_d();
    }
    void set_d(const uint64_t value) {
        set(fields::d, &value, sizeof(uint64_t));
    }
    bool has_e() const {
        return has(fields::e);
    }
    float get_e() {
        return *reinterpret_cast<float*>(get(fields::e));
    }
    const float& get_e() const {
        return const_cast<ScalarTypes*>(this)->get_e();
    }
    void set_e(const float value) {
        set(fields::e, &value, sizeof(float));
    }
    bool has_f() const {
        return has(fields::f);
    }
    double get_f() {
        return *reinterpret_cast<double*>(get(fields::f));
    }
    const double& get_f() const {
        return const_cast<ScalarTypes*>(this)->get_f();
    }
    void set_f(const double value) {
        set(fields::f, &value, sizeof(double));
    }

    #pragma pack(1)
    struct header {
        int8_t ___i = 'i';
        int8_t ___b = 'b';
        int8_t ___s = 's';
        uint8_t ___v = (3 << 4) | 0;
        uint32_t ___sh = 3124513763;
    };
    struct table {
        int8_t a;
        uint16_t b;
        uint8_t __c = 0;
        uint8_t __d = 0;
        float e;
        double f;
    };
    #pragma pack()
private:
    table* get_table() {
        #ifdef _DEBUG
        m_table = reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
        #endif // _DEBUG
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<ScalarTypes*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<ScalarTypes*>(this)->base_ptr();
    }
    #ifdef _DEBUG
    table* m_table = nullptr;
    #endif // _DEBUG
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint8_t m_from_size = 0;
    uint8_t m_table_offset = 0;
}; // struct ScalarTypes

class Vec3f { // struct Vec3f
public:
    Vec3f() {}
    Vec3f(void* from_ptr, const uint32_t from_size = 0) {
        from(from_ptr, from_size);
    }
    Vec3f(const void* from_ptr, const uint32_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = 0;
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(table));
            m_table_offset = 0;
        }
        new(get_table()) table();
    }
    bool from(void* from_ptr, const uint32_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = 0;
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        return true;
    }
    bool from(const void* from_ptr, const uint32_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint32_t table_offset, const void* from_ptr,
            const uint32_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<Vec3f*>(this)->to();
    }
    uint32_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint32_t>(m_buffer->size());
        }
        return 0;
    }
    static uint32_t size_min() {
        return 12;
    }
    static uint32_t size_max() {
        return 12;
    }
    
    struct fields { // enum fields
    enum _ : uint32_t {
        x = 0,
        y = 1,
        z = 2,
        _SPECIAL_ = 3
    };
    static const char* to_string(const _ enum_value) {
        switch(enum_value) {
        case x: return "x";
        case y: return "y";
        case z: return "z";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& string_value) {
        static const std::unordered_map<string_t, _> map = {
            { "x", x },
            { "y", y },
            { "z", z }
        };
        const auto it = map.find(string_value);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* string_value) {
        return from_string(std::string(string_value));
    }
    static constexpr _ min() {
        return x;
    }
    static constexpr _ max() {
        return z;
    }
    static constexpr uint32_t count() {
        return 3;
    }
    static _ at(const uint32_t index) {
        switch (index) {
        case 0: return x;
        case 1: return y;
        case 2: return z;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint32_t offset(const fields::_ field) const {
        static const table o{};
        const table* t = get_table();
        switch (field) {
        case fields::x: return m_table_offset + static_cast<uint32_t>(
            reinterpret_cast<uintptr_t>(&o.x) - reinterpret_cast<uintptr_t>(&o));
        case fields::y: return m_table_offset + static_cast<uint32_t>(
            reinterpret_cast<uintptr_t>(&o.y) - reinterpret_cast<uintptr_t>(&o));
        case fields::z: return m_table_offset + static_cast<uint32_t>(
            reinterpret_cast<uintptr_t>(&o.z) - reinterpret_cast<uintptr_t>(&o));
        }
        return 0;
    }
    bool has(const fields::_ field) const {
        switch (field) {
        case fields::x: return true;
        case fields::y: return true;
        case fields::z: return true;
        }
        return false;
    }
    void* get(const fields::_ field) {
        switch (field) {
        case fields::x: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::y: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::z: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<Vec3f*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint32_t size) {
        if (!has(field)) {
            if (m_from_ptr) {
                return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint32_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::x:
            return sizeof(float);
        case fields::y:
            return sizeof(float);
        case fields::z:
            return sizeof(float);
        default:
            return 0;
        }
        return 0;
    }

    bool has_x() const {
        return has(fields::x);
    }
    float get_x() {
        return *reinterpret_cast<float*>(get(fields::x));
    }
    const float& get_x() const {
        return const_cast<Vec3f*>(this)->get_x();
    }
    void set_x(const float value) {
        set(fields::x, &value, sizeof(float));
    }
    bool has_y() const {
        return has(fields::y);
    }
    float get_y() {
        return *reinterpret_cast<float*>(get(fields::y));
    }
    const float& get_y() const {
        return const_cast<Vec3f*>(this)->get_y();
    }
    void set_y(const float value) {
        set(fields::y, &value, sizeof(float));
    }
    bool has_z() const {
        return has(fields::z);
    }
    float get_z() {
        return *reinterpret_cast<float*>(get(fields::z));
    }
    const float& get_z() const {
        return const_cast<Vec3f*>(this)->get_z();
    }
    void set_z(const float value) {
        set(fields::z, &value, sizeof(float));
    }

    #pragma pack(1)
    struct table {
        float x = 0;
        float y = 0;
        float z = 0;
    };
    #pragma pack()
private:
    table* get_table() {
        #ifdef _DEBUG
        m_table = reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
        #endif // _DEBUG
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<Vec3f*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<Vec3f*>(this)->base_ptr();
    }
    #ifdef _DEBUG
    table* m_table = nullptr;
    #endif // _DEBUG
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint32_t m_from_size = 0;
    uint32_t m_table_offset = 0;
}; // struct Vec3f

static constexpr uint32_t fixedSize = 16;

class Arrays { // struct Arrays
public:
    Arrays() {}
    Arrays(void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    Arrays(const void* from_ptr, const uint16_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = sizeof(header);
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(header) + sizeof(table));
            m_table_offset = sizeof(header);
            new(base_ptr()) header();
        }
        new(get_table()) table();
    }
    bool from(void* from_ptr, const uint16_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = sizeof(header);
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        auto h = reinterpret_cast<const header*>(base_ptr());
        if (h->___i != 'i' || h->___b != 'b' || h->___s != 's') {
            return false;
        }
        if (h->___sh != 4073254500) {
            return false;
        }
        return true;
    }
    bool from(const void* from_ptr, const uint16_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint16_t table_offset, const void* from_ptr,
            const uint16_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<Arrays*>(this)->to();
    }
    uint16_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (calculate > 2) {
                    m_from_size += sizeof(header);
                }
                if (has_f()) {
                    m_from_size += size_f() * sizeof(uint8_t);
                }
                if (has_m()) {
                    m_from_size += size_m() * sizeof(int16_t) + sizeof(uint16_t);
                }
                if (has_v()) {
                    for (uint16_t i = 0, s = size_v(); i < s; ++i) {
                        m_from_size += get_v(i).size(2);
                    } m_from_size += sizeof(uint8_t);
                }
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint16_t>(m_buffer->size());
        }
        return 0;
    }
    static uint16_t size_min() {
        return 30;
    }
    static uint16_t size_max() {
        return 65535;
    }
    
    struct fields { // enum fields
    enum _ : uint16_t {
        f = 0,
        b = 1,
        m = 2,
        v = 3,
        _SPECIAL_ = 4
    };
    static const char* to_string(const _ enum_value) {
        switch(enum_value) {
        case f: return "f";
        case b: return "b";
        case m: return "m";
        case v: return "v";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& string_value) {
        static const std::unordered_map<string_t, _> map = {
            { "f", f },
            { "b", b },
            { "m", m },
            { "v", v }
        };
        const auto it = map.find(string_value);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* string_value) {
        return from_string(std::string(string_value));
    }
    static constexpr _ min() {
        return f;
    }
    static constexpr _ max() {
        return v;
    }
    static constexpr uint16_t count() {
        return 4;
    }
    static _ at(const uint16_t index) {
        switch (index) {
        case 0: return f;
        case 1: return b;
        case 2: return m;
        case 3: return v;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint16_t offset(const fields::_ field) const {
        static const table o{};
        const table* t = get_table();
        switch (field) {
        case fields::f: return t->__f;
        case fields::b: return m_table_offset + static_cast<uint16_t>(
            reinterpret_cast<uintptr_t>(&o.b) - reinterpret_cast<uintptr_t>(&o));
        case fields::m: return t->__m;
        case fields::v: return t->__v;
        }
        return 0;
    }
    bool has(const fields::_ field) const {
        switch (field) {
        case fields::f: return offset(field) > 0;
        case fields::b: return true;
        case fields::m: return offset(field) > 0;
        case fields::v: return offset(field) > 0;
        }
        return false;
    }
    void* get(const fields::_ field) {
        switch (field) {
        case fields::f: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::b: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::m: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field) + sizeof(uint16_t);
        case fields::v: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field) + sizeof(uint8_t);
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<Arrays*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint16_t size) {
        if (!has(field)) {
            if (m_from_ptr) {
                return;
            }
            switch (field) {
            case fields::f:
                get_table()->__f = static_cast<uint16_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(uint8_t) * 16);
                break;
            case fields::m:
                get_table()->__m = static_cast<uint16_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(int16_t) * size + sizeof(uint16_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->__m)) = size;
                break;
            case fields::v:
                get_table()->__v = static_cast<uint16_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(ExtNS::IntNS::Vec3f::table) * size + sizeof(uint8_t));
                *reinterpret_cast<uint16_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->__v)) = size;
                for (uint16_t i = 0; i < size; ++i) {
                    get_v(i).create(UINT32_MAX);
                }
                break;
            default: return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint16_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::f:
            return 16;
        case fields::b:
            return ExtNS::IntNS::fixedSize;
        case fields::m:
            return *(reinterpret_cast<const uint16_t*>(get(field)) - 1);
        case fields::v:
            return *(reinterpret_cast<const uint8_t*>(get(field)) - 1);
        default:
            return 0;
        }
        return 0;
    }

    bool has_f() const {
        return has(fields::f);
    }
    uint8_t& get_f(const uint16_t index) {
        return reinterpret_cast<uint8_t*>(get(fields::f))[index];
    }
    const uint8_t& get_f(const uint16_t index) const {
        return const_cast<Arrays*>(this)->get_f(index);
    }
    void set_f() {
        set(fields::f, nullptr, 16); 
    }
    uint16_t size_f() const {
        return size(fields::f);
    }
    bool has_b() const {
        return has(fields::b);
    }
    uint8_t& get_b(const uint16_t index) {
        return reinterpret_cast<uint8_t*>(get(fields::b))[index];
    }
    const uint8_t& get_b(const uint16_t index) const {
        return const_cast<Arrays*>(this)->get_b(index);
    }
    uint16_t size_b() const {
        return size(fields::b);
    }
    bool has_m() const {
        return has(fields::m);
    }
    int16_t& get_m(const uint16_t index) {
        return reinterpret_cast<int16_t*>(get(fields::m))[index];
    }
    const int16_t& get_m(const uint16_t index) const {
        return const_cast<Arrays*>(this)->get_m(index);
    }
    void set_m(const uint16_t size) {
        set(fields::m, nullptr, size);
    }
    uint16_t size_m() const {
        return size(fields::m);
    }
    bool has_v() const {
        return has(fields::v);
    }
    ExtNS::IntNS::Vec3f& get_v(const uint16_t index) {
        static thread_local ExtNS::IntNS::Vec3f v;
        const auto v_t = &reinterpret_cast<ExtNS::IntNS::Vec3f::table*>(get(fields::v))[index];
        const uint16_t table_offset = static_cast<uint16_t>(
            reinterpret_cast<const uint8_t*>(v_t)
            - reinterpret_cast<const uint8_t*>(base_ptr()));
        v.from(table_offset, m_from_ptr, 0, m_buffer);
        return v;
    }
    const ExtNS::IntNS::Vec3f& get_v(const uint16_t index) const {
        return const_cast<Arrays*>(this)->get_v(index);
    }
    void set_v(const uint16_t size) {
        set(fields::v, nullptr, size);
    }
    uint16_t size_v() const {
        return size(fields::v);
    }

    #pragma pack(1)
    struct header {
        int8_t ___i = 'i';
        int8_t ___b = 'b';
        int8_t ___s = 's';
        uint8_t ___v = (3 << 4) | 0;
        uint32_t ___sh = 4073254500;
    };
    struct table {
        uint16_t __f = 0;
        uint8_t b[ExtNS::IntNS::fixedSize];
        uint16_t __m = 0;
        uint16_t __v = 0;
    };
    #pragma pack()
private:
    table* get_table() {
        #ifdef _DEBUG
        m_table = reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
        #endif // _DEBUG
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<Arrays*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<Arrays*>(this)->base_ptr();
    }
    #ifdef _DEBUG
    table* m_table = nullptr;
    #endif // _DEBUG
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint16_t m_from_size = 0;
    uint16_t m_table_offset = 0;
}; // struct Arrays

class Variant { // union Variant
public:
    Variant() {}
    Variant(void* from_ptr, const uint8_t from_size = 0) {
        from(from_ptr, from_size);
    }
    Variant(const void* from_ptr, const uint8_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = sizeof(header);
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(header) + sizeof(table));
            m_table_offset = sizeof(header);
            new(base_ptr()) header();
        }
        new(get_table()) table();
    }
    bool from(void* from_ptr, const uint8_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = sizeof(header);
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        auto h = reinterpret_cast<const header*>(base_ptr());
        if (h->___i != 'i' || h->___b != 'b' || h->___s != 's') {
            return false;
        }
        if (h->___sh != 1069083227) {
            return false;
        }
        return true;
    }
    bool from(const void* from_ptr, const uint8_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint8_t table_offset, const void* from_ptr,
            const uint8_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<Variant*>(this)->to();
    }
    uint8_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (calculate > 2) {
                    m_from_size += sizeof(header);
                }
                switch (get_table()->variant) {
                case fields::color:
                    m_from_size += size(fields::color);
                    break;
                case fields::data:
                    m_from_size += get_data().size(2);
                    break;
                case fields::arr:
                    m_from_size += size_arr() * sizeof(int64_t) + sizeof(uint8_t);
                    break;
                default: break;
                }
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint8_t>(m_buffer->size());
        }
        return 0;
    }
    static uint8_t size_min() {
        return 10;
    }
    static uint8_t size_max() {
        return 255;
    }
    
    struct fields { // enum fields
    enum _ : uint8_t {
        color = 0,
        data = 1,
        arr = 2,
        _SPECIAL_ = 3
    };
    static const char* to_string(const _ enum_value) {
        switch(enum_value) {
        case color: return "color";
        case data: return "data";
        case arr: return "arr";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& string_value) {
        static const std::unordered_map<string_t, _> map = {
            { "color", color },
            { "data", data },
            { "arr", arr }
        };
        const auto it = map.find(string_value);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* string_value) {
        return from_string(std::string(string_value));
    }
    static constexpr _ min() {
        return color;
    }
    static constexpr _ max() {
        return arr;
    }
    static constexpr uint8_t count() {
        return 3;
    }
    static _ at(const uint8_t index) {
        switch (index) {
        case 0: return color;
        case 1: return data;
        case 2: return arr;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint8_t offset() const {
        return get_table()->offset;
    }
    fields::_ variant() const {
        return get_table()->variant;
    }
    bool has(const fields::_ field) const {
        return get_table()->variant == field;
    }
    void* get(const fields::_ field) {
        switch (get_table()->variant) {
        case fields::color: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset();
        case fields::data: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset();
        case fields::arr: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset() + sizeof(uint8_t);
        default: break;
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<Variant*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint8_t size) {
        if (get_table()->variant == fields::_SPECIAL_) {
            if (m_from_ptr) {
                return;
            }
            get_table()->variant = field;
            get_table()->offset = static_cast<uint8_t>(m_buffer->size());
            switch (field) {
            case fields::color:
                m_buffer->resize(m_buffer->size() + sizeof(ExtNS::IntNS::Color::_));
                break;
            case fields::data:
                m_buffer->resize(m_buffer->size() + sizeof(ExtNS::IntNS::Arrays::table));
                get_data().create(UINT32_MAX);
                break;
            case fields::arr:
                m_buffer->resize(m_buffer->size() + sizeof(uint8_t)
                    + size * sizeof(int64_t));
                *reinterpret_cast<uint8_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->offset)) = size;
                break;
            default: return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint8_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::color:
            return sizeof(ExtNS::IntNS::Color::_);
        case fields::data:
            return sizeof(ExtNS::IntNS::Arrays::table);
        case fields::arr:
            return *(reinterpret_cast<const uint8_t*>(get(field)) - 1);
        default:
            return 0;
        }
        return 0;
    }

    bool has_color() const {
        return has(fields::color);
    }
    ExtNS::IntNS::Color::_ get_color() {
        return *reinterpret_cast<ExtNS::IntNS::Color::_*>(get(fields::color));
    }
    const ExtNS::IntNS::Color::_& get_color() const {
        return const_cast<Variant*>(this)->get_color();
    }
    void set_color(const ExtNS::IntNS::Color::_ value) {
        set(fields::color, &value, sizeof(ExtNS::IntNS::Color::_));
    }
    bool has_data() const {
        return has(fields::data);
    }
    ExtNS::IntNS::Arrays& get_data() {
        static thread_local ExtNS::IntNS::Arrays data;
        const auto data_t = reinterpret_cast<ExtNS::IntNS::Arrays::table*>(get(fields::data));
        const uint8_t table_offset = static_cast<uint8_t>(
            reinterpret_cast<const uint8_t*>(data_t)
            - reinterpret_cast<const uint8_t*>(base_ptr()));
        data.from(table_offset, m_from_ptr, 0, m_buffer);
        return data;
    }
    const ExtNS::IntNS::Arrays& get_data() const {
        return const_cast<Variant*>(this)->get_data();
    }
    void set_data() {
        set(fields::data, nullptr, sizeof(ExtNS::IntNS::Arrays::table));
    }
    bool has_arr() const {
        return has(fields::arr);
    }
    int64_t& get_arr(const uint8_t index) {
        return reinterpret_cast<int64_t*>(get(fields::arr))[index];
    }
    const int64_t& get_arr(const uint8_t index) const {
        return const_cast<Variant*>(this)->get_arr(index);
    }
    void set_arr(const uint8_t size) {
        set(fields::arr, nullptr, size);
    }
    uint8_t size_arr() const {
        return size(fields::arr);
    }

    #pragma pack(1)
    struct header {
        int8_t ___i = 'i';
        int8_t ___b = 'b';
        int8_t ___s = 's';
        uint8_t ___v = (3 << 4) | 0;
        uint32_t ___sh = 1069083227;
    };
    struct table {
        fields::_ variant = fields::_SPECIAL_;
        uint8_t offset = 0;
    };
    #pragma pack()
private:
    table* get_table() {
        #ifdef _DEBUG
        m_table = reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
        #endif // _DEBUG
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<Variant*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<Variant*>(this)->base_ptr();
    }
    #ifdef _DEBUG
    table* m_table = nullptr;
    #endif // _DEBUG
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint8_t m_from_size = 0;
    uint8_t m_table_offset = 0;
}; // union Variant

class AnotherOne { // struct AnotherOne
public:
    AnotherOne() {}
    AnotherOne(void* from_ptr, const uint32_t from_size = 0) {
        from(from_ptr, from_size);
    }
    AnotherOne(const void* from_ptr, const uint32_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = sizeof(header);
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(header) + sizeof(table));
            m_table_offset = sizeof(header);
            new(base_ptr()) header();
        }
        new(get_table()) table();
        get_someData().create(UINT32_MAX);
    }
    bool from(void* from_ptr, const uint32_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = sizeof(header);
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        auto h = reinterpret_cast<const header*>(base_ptr());
        if (h->___i != 'i' || h->___b != 'b' || h->___s != 's') {
            return false;
        }
        if (h->___sh != 3214403770) {
            return false;
        }
        return true;
    }
    bool from(const void* from_ptr, const uint32_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint32_t table_offset, const void* from_ptr,
            const uint32_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<AnotherOne*>(this)->to();
    }
    uint32_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (calculate > 2) {
                    m_from_size += sizeof(header);
                }
                m_from_size += size_string() + sizeof(uint32_t);
                if (has_variant()) {
                    m_from_size += get_variant().size(2);
                }
                m_from_size += get_someData().size(1);
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint32_t>(m_buffer->size());
        }
        return 0;
    }
    static uint32_t size_min() {
        return 28;
    }
    static uint32_t size_max() {
        return 4294967295;
    }
    
    struct fields { // enum fields
    enum _ : uint32_t {
        string = 0,
        variant = 1,
        colorChannels = 2,
        colorMask = 3,
        someData = 4,
        _SPECIAL_ = 5
    };
    static const char* to_string(const _ enum_value) {
        switch(enum_value) {
        case string: return "string";
        case variant: return "variant";
        case colorChannels: return "colorChannels";
        case colorMask: return "colorMask";
        case someData: return "someData";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& string_value) {
        static const std::unordered_map<string_t, _> map = {
            { "string", string },
            { "variant", variant },
            { "colorChannels", colorChannels },
            { "colorMask", colorMask },
            { "someData", someData }
        };
        const auto it = map.find(string_value);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* string_value) {
        return from_string(std::string(string_value));
    }
    static constexpr _ min() {
        return string;
    }
    static constexpr _ max() {
        return someData;
    }
    static constexpr uint32_t count() {
        return 5;
    }
    static _ at(const uint32_t index) {
        switch (index) {
        case 0: return string;
        case 1: return variant;
        case 2: return colorChannels;
        case 3: return colorMask;
        case 4: return someData;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint32_t offset(const fields::_ field) const {
        static const table o{};
        const table* t = get_table();
        switch (field) {
        case fields::string: return t->__string;
        case fields::variant: return t->__variant;
        case fields::colorChannels: return m_table_offset + static_cast<uint32_t>(
            reinterpret_cast<uintptr_t>(&o.colorChannels) - reinterpret_cast<uintptr_t>(&o));
        case fields::colorMask: return m_table_offset + static_cast<uint32_t>(
            reinterpret_cast<uintptr_t>(&o.colorMask) - reinterpret_cast<uintptr_t>(&o));
        case fields::someData: return m_table_offset + static_cast<uint32_t>(
            reinterpret_cast<uintptr_t>(&o.someData) - reinterpret_cast<uintptr_t>(&o));
        }
        return 0;
    }
    bool has(const fields::_ field) const {
        switch (field) {
        case fields::string: return offset(field) > 0;
        case fields::variant: return offset(field) > 0;
        case fields::colorChannels: return true;
        case fields::colorMask: return true;
        case fields::someData: return true;
        }
        return false;
    }
    void* get(const fields::_ field) {
        switch (field) {
        case fields::string: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field) + sizeof(uint32_t);
        case fields::variant: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::colorChannels: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::colorMask: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        case fields::someData: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<AnotherOne*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint32_t size) {
        if (!has(field)) {
            if (m_from_ptr) {
                return;
            }
            switch (field) {
            case fields::string:
                get_table()->__string = static_cast<uint32_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(uint8_t) * size + sizeof(uint32_t));
                *reinterpret_cast<uint32_t*>((reinterpret_cast<uint8_t*>(
                    base_ptr()) + get_table()->__string)) = size;
                break;
            case fields::variant:
                get_table()->__variant = static_cast<uint32_t>(m_buffer->size());
                m_buffer->resize(m_buffer->size()
                    + sizeof(ExtNS::IntNS::Variant::table));
                get_variant().create(UINT32_MAX);
                break;
            default: return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint32_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::string:
            return *(reinterpret_cast<const uint32_t*>(get(field)) - 1);
        case fields::variant:
            return sizeof(ExtNS::IntNS::Variant::table);
        case fields::colorChannels:
            return ExtNS::IntNS::Color::count();
        case fields::colorMask:
            return sizeof(ExtNS::IntNS::Color::_);
        case fields::someData:
            return sizeof(AdditionalNS::SomeType::table);
        default:
            return 0;
        }
        return 0;
    }

    bool has_string() const {
        return has(fields::string);
    }
    uint8_t& get_string(const uint32_t index) {
        return reinterpret_cast<uint8_t*>(get(fields::string))[index];
    }
    const uint8_t& get_string(const uint32_t index) const {
        return const_cast<AnotherOne*>(this)->get_string(index);
    }
    template <typename bytes_t>
    bytes_t get_string() const {
        bytes_t bytes;
        bytes.resize(size_string());
        std::copy(reinterpret_cast<const uint8_t*>(get(fields::string)),
            reinterpret_cast<const uint8_t*>(get(fields::string)) + size_string(),
            reinterpret_cast<uint8_t*>(&bytes[0]));
        return bytes;
    }
    template <typename bytes_t>
    void set_string(const bytes_t& bytes) {
        set(fields::string, bytes.data(), static_cast<uint32_t>(bytes.size()));
    }
    void set_string(const uint32_t size) {
        set(fields::string, nullptr, size);
    }
    uint32_t size_string() const {
        return size(fields::string);
    }
    bool has_variant() const {
        return has(fields::variant);
    }
    ExtNS::IntNS::Variant& get_variant() {
        static thread_local ExtNS::IntNS::Variant variant;
        const auto variant_t = reinterpret_cast<ExtNS::IntNS::Variant::table*>(get(fields::variant));
        const uint32_t table_offset = static_cast<uint32_t>(
            reinterpret_cast<const uint8_t*>(variant_t)
            - reinterpret_cast<const uint8_t*>(base_ptr()));
        variant.from(table_offset, m_from_ptr, 0, m_buffer);
        return variant;
    }
    const ExtNS::IntNS::Variant& get_variant() const {
        return const_cast<AnotherOne*>(this)->get_variant();
    }
    void set_variant() {
        set(fields::variant, nullptr, sizeof(ExtNS::IntNS::Variant::table));
    }
    bool has_colorChannels() const {
        return has(fields::colorChannels);
    }
    ExtNS::IntNS::Color::_ get_colorChannels(const uint32_t index) {
        return reinterpret_cast<ExtNS::IntNS::Color::_*>(get(fields::colorChannels))[index];
    }
    const ExtNS::IntNS::Color::_& get_colorChannels(const uint32_t index) const {
        return const_cast<AnotherOne*>(this)->get_colorChannels(index);
    }
    uint32_t size_colorChannels() const {
        return size(fields::colorChannels);
    }
    bool has_colorMask() const {
        return has(fields::colorMask);
    }
    ExtNS::IntNS::Color::_ get_colorMask() {
        return *reinterpret_cast<ExtNS::IntNS::Color::_*>(get(fields::colorMask));
    }
    const ExtNS::IntNS::Color::_& get_colorMask() const {
        return const_cast<AnotherOne*>(this)->get_colorMask();
    }
    void set_colorMask(const ExtNS::IntNS::Color::_ value) {
        set(fields::colorMask, &value, sizeof(ExtNS::IntNS::Color::_));
    }
    bool has_someData() const {
        return has(fields::someData);
    }
    AdditionalNS::SomeType& get_someData() {
        static thread_local AdditionalNS::SomeType someData;
        const auto someData_t = reinterpret_cast<AdditionalNS::SomeType::table*>(get(fields::someData));
        const uint32_t table_offset = static_cast<uint32_t>(
            reinterpret_cast<const uint8_t*>(someData_t)
            - reinterpret_cast<const uint8_t*>(base_ptr()));
        someData.from(table_offset, m_from_ptr, 0, m_buffer);
        return someData;
    }
    const AdditionalNS::SomeType& get_someData() const {
        return const_cast<AnotherOne*>(this)->get_someData();
    }
    void set_someData() {
        set(fields::someData, nullptr, sizeof(AdditionalNS::SomeType::table));
    }

    #pragma pack(1)
    struct header {
        int8_t ___i = 'i';
        int8_t ___b = 'b';
        int8_t ___s = 's';
        uint8_t ___v = (3 << 4) | 0;
        uint32_t ___sh = 3214403770;
    };
    struct table {
        uint32_t __string = 0;
        uint32_t __variant = 0;
        ExtNS::IntNS::Color::_ colorChannels[ExtNS::IntNS::Color::count()];
        ExtNS::IntNS::Color::_ colorMask = ExtNS::IntNS::Color::BLUE;
        AdditionalNS::SomeType::table someData;
    };
    #pragma pack()
private:
    table* get_table() {
        #ifdef _DEBUG
        m_table = reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
        #endif // _DEBUG
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<AnotherOne*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<AnotherOne*>(this)->base_ptr();
    }
    #ifdef _DEBUG
    table* m_table = nullptr;
    #endif // _DEBUG
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint32_t m_from_size = 0;
    uint32_t m_table_offset = 0;
}; // struct AnotherOne

} // ExtNS
} // IntNS

#endif // SCHEMA_GENERATED_HPP
