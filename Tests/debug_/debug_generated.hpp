// This file was generated by IndexBuffers Compiler 0.3-beta.
// https://github.com/yurablok/IndexBuffers
// Do not modify.
#ifndef DEBUG_DEBUG_GENERATED_HPP
#define DEBUG_DEBUG_GENERATED_HPP

#include <cstdint>
#include <memory>
#include <vector>
#include <string>
#include <unordered_map>

namespace DebugNS {

struct DebugEnum { // enum DebugEnum
enum _ : uint32_t {
    value1 = 0,
    value2 = 1,
    _SPECIAL_ = 2
};
static const char* to_string(const _ enum_value) {
    switch(enum_value) {
    case value1: return "value1";
    case value2: return "value2";
    default: break;
    }
    return nullptr;
}
template <typename string_t>
static _ from_string(const string_t& string_value) {
    static const std::unordered_map<string_t, _> map = {
        { "value1", value1 },
        { "value2", value2 }
    };
    const auto it = map.find(string_value);
    if (it == map.end()) {
        return _SPECIAL_;
    }
    return it->second;
}
static _ from_string(const char* string_value) {
    return from_string(std::string(string_value));
}
static constexpr _ min() {
    return value1;
}
static constexpr _ max() {
    return value2;
}
static constexpr uint32_t count() {
    return 2;
}
static _ at(const uint32_t index) {
    switch (index) {
    case 0: return value1;
    case 1: return value2;
    default: break;
    }
    return _SPECIAL_;
}
}; // enum DebugEnum

static constexpr uint32_t debugConst = 888;
static constexpr int32_t debugNegConst = -888;

class DebugStruct { // struct DebugStruct
public:
    DebugStruct() {}
    DebugStruct(void* from_ptr, const uint32_t from_size = 0) {
        from(from_ptr, from_size);
    }
    DebugStruct(const void* from_ptr, const uint32_t from_size = 0) {
        from(from_ptr, from_size);
    }
    void create(std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_from_ptr = nullptr;
        m_buffer = buffer;
        m_buffer->clear();
        m_table_offset = sizeof(header);
        create(0);
    }
    void create(const uint32_t reserve = 0) {
        if (reserve != UINT32_MAX) {
            m_from_ptr = nullptr;
            m_buffer.reset();
            m_buffer = std::make_shared<std::vector<uint8_t>>();
            m_buffer->reserve(reserve);
            m_buffer->resize(sizeof(header) + sizeof(table));
            m_table_offset = sizeof(header);
            new(base_ptr()) header();
        }
        new(get_table()) table();
    }
    bool from(void* from_ptr, const uint32_t from_size = 0) {
        m_buffer.reset();
        if (from_ptr == nullptr) {
            return false;
        }
        m_from_ptr = reinterpret_cast<uint8_t*>(from_ptr);
        m_table_offset = sizeof(header);
        if (from_size > 0) {
            if (from_size < size_min()) {
                return false;
            }
            if (from_size > size_max()) {
                return false;
            }
            m_from_size = from_size;
        }
        else {
            size(3);
        }
        auto h = reinterpret_cast<const header*>(base_ptr());
        if (h->___i != 'i' || h->___b != 'b' || h->___s != 's') {
            return false;
        }
        if (h->___sh != 2821885152) {
            return false;
        }
        return true;
    }
    bool from(const void* from_ptr, const uint32_t from_size = 0) {
        return from(const_cast<void*>(from_ptr), from_size);
    }
    void from(uint32_t table_offset, const void* from_ptr,
            const uint32_t from_size, std::shared_ptr<std::vector<uint8_t>> buffer) {
        m_table_offset = table_offset;
        m_buffer = buffer;
        m_from_ptr = reinterpret_cast<uint8_t*>(const_cast<void*>(from_ptr));
        m_from_size = from_size;
    }
    void* to() {
        if (m_from_ptr) {
            return m_from_ptr;
        }
        if (m_buffer) {
            return m_buffer->data();
        }
        return nullptr;
    }
    const void* to() const {
        return const_cast<DebugStruct*>(this)->to();
    }
    uint32_t size(const uint8_t calculate = 0) const {
        if (m_from_ptr) {
            if (calculate > 0) {
                m_from_size = 0;
                if (calculate > 1) {
                    m_from_size += sizeof(table);
                }
                if (calculate > 2) {
                    m_from_size += sizeof(header);
                }
            }
            return m_from_size;
        }
        if (m_buffer) {
            return static_cast<uint32_t>(m_buffer->size());
        }
        return 0;
    }
    static uint32_t size_min() {
        return 12;
    }
    static uint32_t size_max() {
        return 12;
    }
    
    struct fields { // enum fields
    enum _ : uint32_t {
        field1 = 0,
        _SPECIAL_ = 1
    };
    static const char* to_string(const _ enum_value) {
        switch(enum_value) {
        case field1: return "field1";
        default: break;
        }
        return nullptr;
    }
    template <typename string_t>
    static _ from_string(const string_t& string_value) {
        static const std::unordered_map<string_t, _> map = {
            { "field1", field1 }
        };
        const auto it = map.find(string_value);
        if (it == map.end()) {
            return _SPECIAL_;
        }
        return it->second;
    }
    static _ from_string(const char* string_value) {
        return from_string(std::string(string_value));
    }
    static constexpr _ min() {
        return field1;
    }
    static constexpr _ max() {
        return field1;
    }
    static constexpr uint32_t count() {
        return 1;
    }
    static _ at(const uint32_t index) {
        switch (index) {
        case 0: return field1;
        default: break;
        }
        return _SPECIAL_;
    }
    }; // enum fields

    uint32_t offset(const fields::_ field) const {
        static const table o{};
        const table* t = get_table();
        switch (field) {
        case fields::field1: return m_table_offset + static_cast<uint32_t>(
            reinterpret_cast<uintptr_t>(&o.field1) - reinterpret_cast<uintptr_t>(&o));
        }
        return 0;
    }
    bool has(const fields::_ field) const {
        switch (field) {
        case fields::field1: return true;
        }
        return false;
    }
    void* get(const fields::_ field) {
        switch (field) {
        case fields::field1: return reinterpret_cast<uint8_t*>(
            base_ptr()) + offset(field);
        }
        return nullptr;
    }
    const void* get(const fields::_ field) const {
        return const_cast<DebugStruct*>(this)->get(field);
    }
    void set(const fields::_ field, const void* data, const uint32_t size) {
        if (!has(field)) {
            if (m_from_ptr) {
                return;
            }
        }
        if (data) {
            std::copy(reinterpret_cast<const uint8_t*>(data),
                reinterpret_cast<const uint8_t*>(data) + size,
                reinterpret_cast<uint8_t*>(get(field)));
        }
    }
    uint32_t size(const fields::_ field) const {
        if (!has(field)) {
            return 0;
        }
        switch (field) {
        case fields::field1:
            return sizeof(uint32_t);
        default:
            return 0;
        }
        return 0;
    }

    bool has_field1() const {
        return has(fields::field1);
    }
    uint32_t get_field1() {
        return *reinterpret_cast<uint32_t*>(get(fields::field1));
    }
    const uint32_t& get_field1() const {
        return const_cast<DebugStruct*>(this)->get_field1();
    }
    void set_field1(const uint32_t value) {
        set(fields::field1, &value, sizeof(uint32_t));
    }

    #pragma pack(1)
    struct header {
        int8_t ___i = 'i';
        int8_t ___b = 'b';
        int8_t ___s = 's';
        uint8_t ___v = (3 << 4) | 0;
        uint32_t ___sh = 2821885152;
    };
    struct table {
        uint32_t field1;
    };
    #pragma pack()
private:
    table* get_table() {
        #ifdef _DEBUG
        m_table = reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
        #endif // _DEBUG
        return reinterpret_cast<table*>(
            reinterpret_cast<uint8_t*>(base_ptr()) + m_table_offset);
    }
    const table* get_table() const {
        return const_cast<DebugStruct*>(this)->get_table();
    }
    void* base_ptr() {
        if (m_buffer) {
            if (m_buffer->empty()) {
                return nullptr;
            }
            return m_buffer->data();
        }
        return m_from_ptr;
    }
    const void* base_ptr() const {
        return const_cast<DebugStruct*>(this)->base_ptr();
    }
    #ifdef _DEBUG
    table* m_table = nullptr;
    #endif // _DEBUG
    std::shared_ptr<std::vector<uint8_t>> m_buffer;
    uint8_t* m_from_ptr = nullptr;
    mutable uint32_t m_from_size = 0;
    uint32_t m_table_offset = 0;
}; // struct DebugStruct

} // DebugNS

#endif // DEBUG_DEBUG_GENERATED_HPP
